// cdb_parser.cpp
// Implementation of the CDB parser for SDCC compiler output files.
//
// This file implements the cdb_parser class, which parses C debug information
// files (CDB) generated by the SDCC compiler, extracting module, function,
// symbol, type, and line information into cdbg_info structures.
//
// Copyright 2025 Tomaz Stih. All rights reserved.
// MIT License.
#include <sstream>
#include <string_view>
#include <algorithm>

#include <sdcc/cdb_parser.h>
#include <sdcc/util.h>

namespace sdcc {

bool cdb_parser::do_parse(const std::string& path) {
    auto lines = util::read_lines(path);
    if (!lines) {
        return false;
    }

    data_.clear();
    current_module_.clear();

    for (const auto& line : *lines) {
        auto trimmed = util::trim(line);
        if (trimmed.empty()) {
            continue;
        }
        parse_line(trimmed);
    }
    return true;
}

void cdb_parser::parse_line(std::string_view line) {
    if (line.empty() || line[1] != ':') {
        return;
    }

    char type = line[0];
    std::string_view content = line.substr(2);

    switch (type) {
        case 'M': parse_module(content); break;
        case 'F': parse_function(content); break;
        case 'S': parse_symbol(content); break;
        case 'T': parse_type(content); break;
        case 'L': parse_line_info(content); break;
        default: break; // Ignore unknown types
    }
}

void cdb_parser::parse_module(std::string_view content) {
    cdbg_info_module module;
    module.name = std::string(content);
    module.file = module.name + ".c"; // Default file path
    current_module_ = module.name;
    data_.push_back(module);
}

void cdb_parser::parse_function(std::string_view content) {
    // Example: F:G$clock_init$0_0$0({2}DF,SV:S),Z,0,0,0,0,0
    if (current_module_.empty()) return; // No module context

    cdbg_info_function func;
    func.scope = (content[0] == 'G') ? "global" : "local";

    // Split at first '$' to get name
    size_t dollar_pos = content.find('$');
    if (dollar_pos == std::string_view::npos) return;

    size_t next_dollar = content.find('$', dollar_pos + 1);
    if (next_dollar == std::string_view::npos) return;

    func.name = std::string(content.substr(dollar_pos + 1, next_dollar - dollar_pos - 1));
    // Remove module prefix if present (e.g., "clock." in "clock.clock_init")
    size_t dot_pos = func.name.find('.');
    if (dot_pos != std::string::npos) {
        func.name = func.name.substr(dot_pos + 1);
    }

    // Add to current module
    for (auto& module : data_) {
        if (module.name == current_module_) {
            module.functions.push_back(func);
            break;
        }
    }
}

void cdb_parser::parse_symbol(std::string_view content) {
    // Examples:
    // S:Lclock.clock_loop$hour$1_1$41({2}SI:S),B,1,-2
    // S:G$SECOND$0_0$0({1}SC:U),I,0,0
    if (current_module_.empty()) return;

    cdbg_info_symbol symbol;
    symbol.scope = (content[0] == 'G') ? "global" : "local";

    // Find name and type info
    size_t dollar_pos = content.find('$');
    if (dollar_pos == std::string_view::npos) return;

    size_t name_end = content.find('$', dollar_pos + 1);
    size_t paren_pos = content.find('(');
    if (name_end == std::string_view::npos || (paren_pos != std::string_view::npos && paren_pos < name_end)) {
        name_end = paren_pos;
    }
    if (name_end == std::string_view::npos) return;

    std::string full_name = std::string(content.substr(dollar_pos + 1, name_end - dollar_pos - 1));
    // Extract type info (e.g., "{2}SI:S"), excluding parentheses
    if (paren_pos != std::string_view::npos) {
        size_t end_paren = content.find(')', paren_pos);
        if (end_paren != std::string_view::npos) {
            symbol.type_info = std::string(content.substr(paren_pos + 1, end_paren - paren_pos - 1));
        }
    }

    // Handle local vs. global symbols
    if (symbol.scope == "local") {
        // Local symbol, e.g., "Lclock.clock_loop$hour" -> function "clock_loop", name "hour"
        size_t first_dot = full_name.find('.');
        if (first_dot == std::string::npos) return;

        std::string module_name = full_name.substr(0, first_dot);
        size_t second_dollar = full_name.find('$', first_dot + 1);
        if (second_dollar == std::string::npos) return;

        std::string function_name = full_name.substr(first_dot + 1, second_dollar - first_dot - 1);
        symbol.name = full_name.substr(second_dollar + 1);

        // Add to the appropriate function in the current module
        for (auto& module : data_) {
            if (module.name == current_module_ && module_name == current_module_) {
                for (auto& func : module.functions) {
                    if (func.name == function_name) {
                        func.local_symbols.push_back(symbol);
                        return;
                    }
                }
            }
        }
    } else {
        // Global symbol
        size_t dot_pos = full_name.find('.');
        if (dot_pos != std::string::npos) {
            symbol.name = full_name.substr(dot_pos + 1);
        } else {
            symbol.name = full_name;
        }

        // Add to current module's global symbols
        for (auto& module : data_) {
            if (module.name == current_module_) {
                module.global_symbols.push_back(symbol);
                break;
            }
        }
    }
}

void cdb_parser::parse_type(std::string_view content) {
    // Example: T:Fclock$dim_s[({0}S:S$w$0_0$0({2}SI:S),Z,0,0)({2}S:S$h$0_0$0({2}SI:S),Z,0,0)]
    if (current_module_.empty()) return;

    cdbg_info_type type;
    type.scope = (content[0] == 'G') ? "global" : "local";

    // Split at first '$' to get name
    size_t dollar_pos = content.find('$');
    if (dollar_pos == std::string_view::npos) return;

    size_t bracket_pos = content.find('[');
    if (bracket_pos == std::string_view::npos) return;

    std::string full_name = std::string(content.substr(dollar_pos + 1, bracket_pos - dollar_pos - 1));
    // Extract type info
    size_t end_bracket = content.find_last_of(']');
    if (end_bracket != std::string_view::npos) {
        type.type_info = std::string(content.substr(bracket_pos, end_bracket - bracket_pos + 1));
    }

    // Remove module prefix
    size_t dot_pos = full_name.find('.');
    if (dot_pos != std::string::npos) {
        type.name = full_name.substr(dot_pos + 1);
    } else {
        type.name = full_name;
    }

    // Add to current module
    for (auto& module : data_) {
        if (module.name == current_module_) {
            module.types.push_back(type);
            break;
        }
    }
}

void cdb_parser::parse_line_info(std::string_view content) {
    // Examples:
    // L:G$SECOND$0_0$0:A2
    // L:C$clock.c$18$0_0$36:116
    // L:A$clock/tomaz/Work/ura/build/ura/clock$76:116
    if (current_module_.empty()) return;

    cdbg_info_line line;
    line.scope = (content[0] == 'G') ? "global" : "local";

    // Split by '$'
    auto parts = util::split(content, '$');
    if (parts.size() < 3) return;

    // File path is the second part (index 1)
    line.file = std::string(parts[1]);
    // Normalize file path to use forward slashes
    std::replace(line.file.begin(), line.file.end(), '\\', '/');

    // Line number is in the last part, before ':' or end
    std::string_view last_part = parts.back();
    size_t colon_pos = last_part.find(':');
    std::string_view line_str = (colon_pos != std::string_view::npos) ? last_part.substr(0, colon_pos) : last_part;

    try {
        line.line = std::stoi(std::string(line_str), nullptr, 16);
    } catch (...) {
        return; // Skip invalid line numbers
    }

    // Add to current module
    for (auto& module : data_) {
        if (module.name == current_module_) {
            // Set module file to the first .c file path encountered
            if (module.file.empty() || module.file == current_module_ + ".c") {
                if (line.file.find(".c") != std::string::npos) {
                    module.file = line.file;
                }
            }
            module.lines.push_back(line);
            break;
        }
    }
}

} // namespace sdcc