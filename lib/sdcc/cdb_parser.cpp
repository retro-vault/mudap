// cdb_parser.cpp
// Implementation of the CDB parser for SDCC compiler output files.
//
// This file implements the cdb_parser class, which parses C debug information
// files (CDB) generated by the SDCC compiler, extracting module, function,
// symbol, type, and line information into cdbg_info structures.
//
// Copyright 2025 Tomaz Stih. All rights reserved.
// MIT License.
#include <sstream>
#include <string_view>
#include <algorithm>

#include <sdcc/cdb_parser.h>
#include <sdcc/util.h>

namespace sdcc {

bool cdb_parser::do_parse(const std::string& path) {
    auto lines = util::read_lines(path);
    if (!lines) {
        return false;
    }

    data_.clear();
    current_module_.clear();

    for (const auto& line : *lines) {
        auto trimmed = util::trim(line);
        if (trimmed.empty()) {
            continue;
        }
        parse_line(trimmed);
    }
    return true;
}

void cdb_parser::parse_line(std::string_view line) {
    if (line.empty() || line[1] != ':') {
        return;
    }

    char type = line[0];
    std::string_view content = line.substr(2);

    switch (type) {
        case 'M': parse_module(content); break;
        case 'F': parse_function(content); break;
        case 'S': parse_symbol(content); break;
        case 'T': parse_type(content); break;
        case 'L': parse_line_info(content); break;
        default: break; // Ignore unknown types
    }
}

void cdb_parser::parse_module(std::string_view content) {
    cdbg_info_module module;
    module.name = std::string(content);
    module.file = module.name + ".c"; // Default file path
    current_module_ = module.name;
    data_.push_back(module);
}

void cdb_parser::parse_function(std::string_view content) {
    // Example: F:G$clock_init$0_0$0({2}DF,SV:S),Z,0,0,0,0,0
    if (current_module_.empty()) return; // No module context

    cdbg_info_function func;
    func.scope = (content[0] == 'G') ? "global" : "local";

    // Split at first '$' to get name
    size_t dollar_pos = content.find('$');
    if (dollar_pos == std::string_view::npos) return;

    size_t next_dollar = content.find('$', dollar_pos + 1);
    if (next_dollar == std::string_view::npos) return;

    func.name = std::string(content.substr(dollar_pos + 1, next_dollar - dollar_pos - 1));
    // Remove module prefix if present (e.g., "clock." in "clock.clock_init")
    size_t dot_pos = func.name.find('.');
    if (dot_pos != std::string::npos) {
        func.name = func.name.substr(dot_pos + 1);
    }

    // Add to current module
    for (auto& module : data_) {
        if (module.name == current_module_) {
            module.functions.push_back(func);
            break;
        }
    }
}

void cdb_parser::parse_symbol(std::string_view content) {
    // Examples:
    // S:Lclock.clock_loop$hour$1_1$41({2}SI:S),B,1,-2
    // S:G$SECOND$0_0$0({1}SC:U),I,0,0
    // S:Fclock$clk$0_0$0({97}STclock_s:S),E,0,0
    if (current_module_.empty()) return;

    cdbg_info_symbol symbol;
    char scope_char = content[0];

    // First '$' separates scope prefix from symbol name
    size_t dollar_pos = content.find('$');
    if (dollar_pos == std::string_view::npos) return;

    // Scope prefix is between scope char and first '$'
    // e.g. "clock.clock_loop" for L, empty for G
    std::string_view scope_prefix = content.substr(1, dollar_pos - 1);

    // Symbol name is between first and second '$'
    size_t name_end = content.find('$', dollar_pos + 1);
    if (name_end == std::string_view::npos) return;
    std::string sym_name(content.substr(dollar_pos + 1, name_end - dollar_pos - 1));

    // Extract type info from parentheses, e.g. "{2}SI:S"
    size_t paren_pos = content.find('(');
    if (paren_pos != std::string_view::npos) {
        size_t end_paren = content.find(')', paren_pos);
        if (end_paren != std::string_view::npos) {
            symbol.type_info = std::string(content.substr(paren_pos + 1, end_paren - paren_pos - 1));
        }
    }

    symbol.name = sym_name;

    if (scope_char == 'L') {
        // Local symbol: scope_prefix = "clock.clock_loop" (module.function)
        symbol.scope = "local";
        size_t dot_pos = scope_prefix.find('.');
        if (dot_pos == std::string_view::npos) return;

        std::string module_name(scope_prefix.substr(0, dot_pos));
        std::string function_name(scope_prefix.substr(dot_pos + 1));

        for (auto& module : data_) {
            if (module.name == current_module_ && module_name == current_module_) {
                for (auto& func : module.functions) {
                    if (func.name == function_name) {
                        func.local_symbols.push_back(symbol);
                        return;
                    }
                }
            }
        }
    } else if (scope_char == 'G') {
        // Global symbol: name is between 1st and 2nd '$'
        symbol.scope = "global";
        for (auto& module : data_) {
            if (module.name == current_module_) {
                module.global_symbols.push_back(symbol);
                break;
            }
        }
    } else {
        // File-scope (F) or struct-scope (S) â€” add as module-level symbol
        symbol.scope = (scope_char == 'F') ? "local" : "struct";
        for (auto& module : data_) {
            if (module.name == current_module_) {
                module.global_symbols.push_back(symbol);
                break;
            }
        }
    }
}

void cdb_parser::parse_type(std::string_view content) {
    // Example: T:Fclock$dim_s[({0}S:S$w$0_0$0({2}SI:S),Z,0,0)({2}S:S$h$0_0$0({2}SI:S),Z,0,0)]
    if (current_module_.empty()) return;

    cdbg_info_type type;
    type.scope = (content[0] == 'G') ? "global" : "local";

    // Split at first '$' to get name
    size_t dollar_pos = content.find('$');
    if (dollar_pos == std::string_view::npos) return;

    size_t bracket_pos = content.find('[');
    if (bracket_pos == std::string_view::npos) return;

    std::string full_name = std::string(content.substr(dollar_pos + 1, bracket_pos - dollar_pos - 1));
    // Extract type info
    size_t end_bracket = content.find_last_of(']');
    if (end_bracket != std::string_view::npos) {
        type.type_info = std::string(content.substr(bracket_pos, end_bracket - bracket_pos + 1));
    }

    // Remove module prefix
    size_t dot_pos = full_name.find('.');
    if (dot_pos != std::string::npos) {
        type.name = full_name.substr(dot_pos + 1);
    } else {
        type.name = full_name;
    }

    // Add to current module
    for (auto& module : data_) {
        if (module.name == current_module_) {
            module.types.push_back(type);
            break;
        }
    }
}

void cdb_parser::parse_line_info(std::string_view content) {
    // Examples:
    // L:C$clock.c$18$0_0$36:116    (C source line)
    // L:A$clock/path/clock$76:116   (Assembly line)
    // L:G$SECOND$0_0$0:A2           (Global symbol address)
    if (current_module_.empty()) return;

    char type = content[0];

    // Only handle C source lines for now
    // Format: C$file$line$level$block:address
    if (type != 'C') return;

    auto parts = util::split(content, '$');
    // parts: ["C", "clock.c", "18", "0_0", "36:116"]
    if (parts.size() < 4) return;

    cdbg_info_line line;
    line.scope = "local";
    line.file = std::string(parts[1]);
    std::replace(line.file.begin(), line.file.end(), '\\', '/');

    // Line number is parts[2], decimal
    try {
        line.line = std::stoi(std::string(parts[2]));
    } catch (...) {
        return;
    }

    // Address is after the last ':' in the last part
    std::string_view last_part = parts.back();
    size_t colon_pos = last_part.find(':');
    if (colon_pos != std::string_view::npos) {
        try {
            line.address = static_cast<uint16_t>(
                std::stoul(std::string(last_part.substr(colon_pos + 1)), nullptr, 16));
        } catch (...) {
            // Address is optional, ignore parse errors
        }
    }

    // Match module by file name rather than current_module_, because
    // L: records can appear after a different M: record in the CDB file.
    // e.g. "clock.c" -> module "clock"
    std::string module_name;
    size_t dot_pos = line.file.rfind('.');
    if (dot_pos != std::string::npos) {
        module_name = line.file.substr(0, dot_pos);
    }

    for (auto& module : data_) {
        if (module.name == module_name) {
            if (module.file == module.name + ".c") {
                module.file = line.file;
            }
            module.lines.push_back(line);
            return;
        }
    }
}

} // namespace sdcc